import{a2 as Y,u as J,p as U,E as D,a3 as F,a4 as K,a5 as $,m as H,a6 as R,a7 as f,a8 as z,a9 as B,aa as W,ab as Z,ac as j,ad as q,ae as Q,af as V,ag as tt,ah as A,ai as et,aj as it,$ as w,ak as st,al as rt,am as nt,an as ot,ao as at,ap as lt,aq as M,ar as ht,as as dt,at as ut,au as x,av as ct,aw as S,ax as gt,ay as N,az as T,_ as k,y as c,aA as d,t as ft,aB as yt,aC as mt,aD as pt,aE as Ct,aF as y}from"./index-DhN24NV8.js";class C extends Y{constructor(t){super(),this.geometries_=t,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(J),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const t=this.geometries_;for(let e=0,i=t.length;e<i;++e)this.changeEventsKeys_.push(U(t[e],D.CHANGE,this.changed,this))}clone(){const t=new C(O(this.geometries_));return t.applyProperties(this),t}closestPointXY(t,e,i,s){if(s<F(this.getExtent(),t,e))return s;const n=this.geometries_;for(let o=0,a=n.length;o<a;++o)s=n[o].closestPointXY(t,e,i,s);return s}containsXY(t,e){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)if(i[s].containsXY(t,e))return!0;return!1}computeExtent(t){K(t);const e=this.geometries_;for(let i=0,s=e.length;i<s;++i)$(t,e[i].getExtent());return t}getGeometries(){return O(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let t=[];const e=this.geometries_;for(let i=0,s=e.length;i<s;++i)e[i].getType()===this.getType()?t=t.concat(e[i].getGeometriesArrayRecursive()):t.push(e[i]);return t}getSimplifiedGeometry(t){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=[],i=this.geometries_;let s=!1;for(let n=0,o=i.length;n<o;++n){const a=i[n],l=a.getSimplifiedGeometry(t);e.push(l),l!==a&&(s=!0)}return s?new C(e):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)}getType(){return"GeometryCollection"}intersectsExtent(t){const e=this.geometries_;for(let i=0,s=e.length;i<s;++i)if(e[i].intersectsExtent(t))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(t,e){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)i[s].rotate(t,e);this.changed()}scale(t,e,i){i||(i=H(this.getExtent()));const s=this.geometries_;for(let n=0,o=s.length;n<o;++n)s[n].scale(t,e,i);this.changed()}setGeometries(t){this.setGeometriesArray(O(t))}setGeometriesArray(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()}applyTransform(t){const e=this.geometries_;for(let i=0,s=e.length;i<s;++i)e[i].applyTransform(t);this.changed()}translate(t,e){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)i[s].translate(t,e);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function O(r){return r.map(t=>t.clone())}class P extends R{constructor(t,e,i){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(e!==void 0&&i)this.setFlatCoordinates(e,t),this.ends_=i;else{const s=t,n=[],o=[];for(let l=0,h=s.length;l<h;++l){const u=s[l];f(n,u.getFlatCoordinates()),o.push(n.length)}const a=s.length===0?this.getLayout():s[0].getLayout();this.setFlatCoordinates(a,n),this.ends_=o}}appendLineString(t){f(this.flatCoordinates,t.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new P(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,i,s){return s<F(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(z(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),B(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,i,s))}getCoordinateAtM(t,e,i){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(e=e!==void 0?e:!1,i=i!==void 0?i:!1,W(this.flatCoordinates,0,this.ends_,this.stride,t,e,i))}getCoordinates(){return Z(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new j(this.flatCoordinates.slice(t===0?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const t=this.flatCoordinates,e=this.ends_,i=this.layout,s=[];let n=0;for(let o=0,a=e.length;o<a;++o){const l=e[o],h=new j(t.slice(n,l),i);s.push(h),n=l}return s}getLength(){const t=this.ends_;let e=0,i=0;for(let s=0,n=t.length;s<n;++s)i+=q(this.flatCoordinates,e,t[s],this.stride),e=t[s];return i}getFlatMidpoints(){const t=[],e=this.flatCoordinates;let i=0;const s=this.ends_,n=this.stride;for(let o=0,a=s.length;o<a;++o){const l=s[o],h=Q(e,i,l,n,.5);f(t,h),i=l}return t}getSimplifiedGeometryInternal(t){const e=[],i=[];return e.length=V(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,i),new P(e,"XY",i)}getType(){return"MultiLineString"}intersectsExtent(t){return tt(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const i=A(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=i.length===0?0:i[i.length-1],this.changed()}}class G extends R{constructor(t,e){super(),e&&!Array.isArray(t[0])?this.setFlatCoordinates(e,t):this.setCoordinates(t,e)}appendPoint(t){f(this.flatCoordinates,t.getFlatCoordinates()),this.changed()}clone(){const t=new G(this.flatCoordinates.slice(),this.layout);return t.applyProperties(this),t}closestPointXY(t,e,i,s){if(s<F(this.getExtent(),t,e))return s;const n=this.flatCoordinates,o=this.stride;for(let a=0,l=n.length;a<l;a+=o){const h=et(t,e,n[a],n[a+1]);if(h<s){s=h;for(let u=0;u<o;++u)i[u]=n[a+u];i.length=o}}return s}getCoordinates(){return it(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(t){const e=this.flatCoordinates.length/this.stride;return t<0||e<=t?null:new w(this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride),this.layout)}getPoints(){const t=this.flatCoordinates,e=this.layout,i=this.stride,s=[];for(let n=0,o=t.length;n<o;n+=i){const a=new w(t.slice(n,n+i),e);s.push(a)}return s}getType(){return"MultiPoint"}intersectsExtent(t){const e=this.flatCoordinates,i=this.stride;for(let s=0,n=e.length;s<n;s+=i){const o=e[s],a=e[s+1];if(st(t,o,a))return!0}return!1}setCoordinates(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=rt(this.flatCoordinates,0,t,this.stride),this.changed()}}class _ extends R{constructor(t,e,i){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!i&&!Array.isArray(t[0])){const s=t,n=[],o=[];for(let a=0,l=s.length;a<l;++a){const h=s[a],u=n.length,g=h.getEnds();for(let m=0,X=g.length;m<X;++m)g[m]+=u;f(n,h.getFlatCoordinates()),o.push(g)}e=s.length===0?this.getLayout():s[0].getLayout(),t=n,i=o}e!==void 0&&i?(this.setFlatCoordinates(e,t),this.endss_=i):this.setCoordinates(t,e)}appendPolygon(t){let e;if(!this.flatCoordinates)this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();else{const i=this.flatCoordinates.length;f(this.flatCoordinates,t.getFlatCoordinates()),e=t.getEnds().slice();for(let s=0,n=e.length;s<n;++s)e[s]+=i}this.endss_.push(e),this.changed()}clone(){const t=this.endss_.length,e=new Array(t);for(let s=0;s<t;++s)e[s]=this.endss_[s].slice();const i=new _(this.flatCoordinates.slice(),this.layout,e);return i.applyProperties(this),i}closestPointXY(t,e,i,s){return s<F(this.getExtent(),t,e)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(nt(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),ot(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,i,s))}containsXY(t,e){return at(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return lt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return t!==void 0?(e=this.getOrientedFlatCoordinates().slice(),M(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,ht(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=dt(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=ut(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new G(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;x(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=M(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],i=[];return e.length=ct(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,i),new _(e,"XY",i)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let e;if(t===0)e=0;else{const n=this.endss_[t-1];e=n[n.length-1]}const i=this.endss_[t].slice(),s=i[i.length-1];if(e!==0)for(let n=0,o=i.length;n<o;++n)i[n]-=e;return new S(this.flatCoordinates.slice(e,s),this.layout,i)}getPolygons(){const t=this.layout,e=this.flatCoordinates,i=this.endss_,s=[];let n=0;for(let o=0,a=i.length;o<a;++o){const l=i[o].slice(),h=l[l.length-1];if(n!==0)for(let g=0,m=l.length;g<m;++g)l[g]-=n;const u=new S(e.slice(n,h),t,l);s.push(u),n=h}return s}getType(){return"MultiPolygon"}intersectsExtent(t){return gt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const i=N(this.flatCoordinates,0,t,this.stride,this.endss_);if(i.length===0)this.flatCoordinates.length=0;else{const s=i[i.length-1];this.flatCoordinates.length=s.length===0?0:s[s.length-1]}this.changed()}}class Pt{constructor(){this.dataProjection=void 0,this.defaultFeatureProjection=void 0,this.featureClass=k,this.supportedMediaTypes=null}getReadOptions(t,e){if(e){let i=e.dataProjection?c(e.dataProjection):this.readProjection(t);e.extent&&i&&i.getUnits()==="tile-pixels"&&(i=c(i),i.setWorldExtent(e.extent)),e={dataProjection:i,featureProjection:e.featureProjection}}return this.adaptOptions(e)}adaptOptions(t){return Object.assign({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection,featureClass:this.featureClass},t)}getType(){return d()}readFeature(t,e){return d()}readFeatures(t,e){return d()}readGeometry(t,e){return d()}readProjection(t){return d()}writeFeature(t,e){return d()}writeFeatures(t,e){return d()}writeGeometry(t,e){return d()}}function v(r,t,e){const i=e?c(e.featureProjection):null,s=e?c(e.dataProjection):null;let n=r;if(i&&s&&!ft(i,s)){t&&(n=r.clone());const o=t?i:s,a=t?s:i;o.getUnits()==="tile-pixels"?n.transform(o,a):n.applyTransform(yt(o,a))}if(t&&e&&e.decimals!==void 0){const o=Math.pow(10,e.decimals),a=function(l){for(let h=0,u=l.length;h<u;++h)l[h]=Math.round(l[h]*o)/o;return l};n===r&&(n=r.clone()),n.applyTransform(a)}return n}const _t={Point:w,LineString:j,Polygon:S,MultiPoint:G,MultiLineString:P,MultiPolygon:_};function Ft(r,t,e){return Array.isArray(t[0])?(x(r,0,t,e)||(r=r.slice(),M(r,0,t,e)),r):(mt(r,0,t,e)||(r=r.slice(),pt(r,0,t,e)),r)}function I(r,t){const e=r.geometry;if(!e)return[];if(Array.isArray(e))return e.map(n=>I({...r,geometry:n})).flat();const i=e.type==="MultiPolygon"?"Polygon":e.type;if(i==="GeometryCollection"||i==="Circle")throw new Error("Unsupported geometry type: "+i);const s=e.layout.length;return v(new T(i,i==="Polygon"?Ft(e.flatCoordinates,e.ends,s):e.flatCoordinates,e.ends?.flat(),s,r.properties||{},r.id).enableSimplifyTransformed(),!1,t)}function b(r,t){if(!r)return null;if(Array.isArray(r)){const i=r.map(s=>b(s,t));return new C(i)}const e=_t[r.type];return v(new e(r.flatCoordinates,r.layout||"XY",r.ends),!1,t)}class Gt extends Pt{constructor(){super()}getType(){return"json"}readFeature(t,e){return this.readFeatureFromObject(p(t),this.getReadOptions(t,e))}readFeatures(t,e){return this.readFeaturesFromObject(p(t),this.getReadOptions(t,e))}readFeatureFromObject(t,e){return d()}readFeaturesFromObject(t,e){return d()}readGeometry(t,e){return this.readGeometryFromObject(p(t),this.getReadOptions(t,e))}readGeometryFromObject(t,e){return d()}readProjection(t){return this.readProjectionFromObject(p(t))}readProjectionFromObject(t){return d()}writeFeature(t,e){return JSON.stringify(this.writeFeatureObject(t,e))}writeFeatureObject(t,e){return d()}writeFeatures(t,e){return JSON.stringify(this.writeFeaturesObject(t,e))}writeFeaturesObject(t,e){return d()}writeGeometry(t,e){return JSON.stringify(this.writeGeometryObject(t,e))}writeGeometryObject(t,e){return d()}}function p(r){if(typeof r=="string"){const t=JSON.parse(r);return t||null}return r!==null?r:null}class Xt extends Gt{constructor(t){t=t||{},super(),this.dataProjection=c(t.dataProjection?t.dataProjection:"EPSG:4326"),t.featureProjection&&(this.defaultFeatureProjection=c(t.featureProjection)),t.featureClass&&(this.featureClass=t.featureClass),this.geometryName_=t.geometryName,this.extractGeometryName_=t.extractGeometryName,this.supportedMediaTypes=["application/geo+json","application/vnd.geo+json"]}readFeatureFromObject(t,e){let i=null;t.type==="Feature"?i=t:i={type:"Feature",geometry:t,properties:null};const s=L(i.geometry);if(this.featureClass===T)return I({geometry:s,id:i.id,properties:i.properties},e);const n=new k;return this.geometryName_?n.setGeometryName(this.geometryName_):this.extractGeometryName_&&i.geometry_name&&n.setGeometryName(i.geometry_name),n.setGeometry(b(s,e)),"id"in i&&n.setId(i.id),i.properties&&n.setProperties(i.properties,!0),n}readFeaturesFromObject(t,e){const i=t;let s=null;if(i.type==="FeatureCollection"){const n=t;s=[];const o=n.features;for(let a=0,l=o.length;a<l;++a){const h=this.readFeatureFromObject(o[a],e);h&&s.push(h)}}else s=[this.readFeatureFromObject(t,e)];return s.flat()}readGeometryFromObject(t,e){return Ot(t,e)}readProjectionFromObject(t){const e=t.crs;let i;if(e)if(e.type=="name")i=c(e.properties.name);else if(e.type==="EPSG")i=c("EPSG:"+e.properties.code);else throw new Error("Unknown SRS type");else i=this.dataProjection;return i}writeFeatureObject(t,e){e=this.adaptOptions(e);const i={type:"Feature",geometry:null,properties:null},s=t.getId();if(s!==void 0&&(i.id=s),!t.hasProperties())return i;const n=t.getProperties(),o=t.getGeometry();return o&&(i.geometry=E(o,e),delete n[t.getGeometryName()]),Ct(n)||(i.properties=n),i}writeFeaturesObject(t,e){e=this.adaptOptions(e);const i=[];for(let s=0,n=t.length;s<n;++s)i.push(this.writeFeatureObject(t[s],e));return{type:"FeatureCollection",features:i}}writeGeometryObject(t,e){return E(t,this.adaptOptions(e))}}function L(r,t){if(!r)return null;let e;switch(r.type){case"Point":{e=wt(r);break}case"LineString":{e=Mt(r);break}case"Polygon":{e=At(r);break}case"MultiPoint":{e=Et(r);break}case"MultiLineString":{e=St(r);break}case"MultiPolygon":{e=Rt(r);break}case"GeometryCollection":{e=jt(r);break}default:throw new Error("Unsupported GeoJSON type: "+r.type)}return e}function Ot(r,t){const e=L(r);return b(e,t)}function jt(r,t){return r.geometries.map(function(i){return L(i)})}function wt(r){const t=r.coordinates;return{type:"Point",flatCoordinates:t,layout:y(t.length)}}function Mt(r){const t=r.coordinates,e=t.flat();return{type:"LineString",flatCoordinates:e,ends:[e.length],layout:y(t[0]?.length||2)}}function St(r){const t=r.coordinates,e=t[0]?.[0]?.length||2,i=[],s=A(i,0,t,e);return{type:"MultiLineString",flatCoordinates:i,ends:s,layout:y(e)}}function Et(r){const t=r.coordinates;return{type:"MultiPoint",flatCoordinates:t.flat(),layout:y(t[0]?.length||2)}}function Rt(r){const t=r.coordinates,e=[],i=t[0]?.[0]?.[0].length||2,s=N(e,0,t,i);return{type:"MultiPolygon",flatCoordinates:e,ends:s,layout:y(i)}}function At(r){const t=r.coordinates,e=[],i=t[0]?.[0]?.length,s=A(e,0,t,i);return{type:"Polygon",flatCoordinates:e,ends:s,layout:y(i)}}function E(r,t){r=v(r,!0,t);const e=r.getType();let i;switch(e){case"Point":{i=Tt(r);break}case"LineString":{i=bt(r);break}case"Polygon":{i=kt(r,t);break}case"MultiPoint":{i=xt(r);break}case"MultiLineString":{i=Lt(r);break}case"MultiPolygon":{i=Nt(r,t);break}case"GeometryCollection":{i=vt(r,t);break}case"Circle":{i={type:"GeometryCollection",geometries:[]};break}default:throw new Error("Unsupported geometry type: "+e)}return i}function vt(r,t){return t=Object.assign({},t),delete t.featureProjection,{type:"GeometryCollection",geometries:r.getGeometriesArray().map(function(i){return E(i,t)})}}function bt(r,t){return{type:"LineString",coordinates:r.getCoordinates()}}function Lt(r,t){return{type:"MultiLineString",coordinates:r.getCoordinates()}}function xt(r,t){return{type:"MultiPoint",coordinates:r.getCoordinates()}}function Nt(r,t){let e;return t&&(e=t.rightHanded),{type:"MultiPolygon",coordinates:r.getCoordinates(e)}}function Tt(r,t){return{type:"Point",coordinates:r.getCoordinates()}}function kt(r,t){let e;return t&&(e=t.rightHanded),{type:"Polygon",coordinates:r.getCoordinates(e)}}export{Xt as G};
//# sourceMappingURL=GeoJSON-CEuMSiEL.js.map
